Zookeeper是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。

通过对Zookeeper中丰富的数据节点进行交叉使用，配合Watcher事件通知机制，可以非常方便的构建一系列分布式应用中都会涉及的核心功能，如：

1. 数据发布/订阅
2. 负载均衡
3. 命名服务
4. 分布式协调/通知
5. 集群管理
6. Master选举
7. 分布式锁
8. 分布式队列



（1）数据发布/订阅

数据的发布与订阅：一方把数据发布出来，另一方通过某种手段获取。

两种模式：推模式和拉模式，

推模式一般是服务器主动往客户端推送信息，

拉模式是客户端主动去服务端请求目标数据（通常采用定时轮询的方式）

Zookeeper采用两种方式互相结合：

发布者将数据发布到Zookeeper集群节点上，订阅者通过一定的方法告诉Zookeeper服务器，自己对哪个节点的数据感兴趣，那么在服务端数据发生变化时，就会通知客户端去获取这些信息。

<img src="..\resource\zookeeper发布订阅.png" style="zoom:80%;" />



（2）负载均衡

　首先在服务端启动的时候，把自己在zookeeper服务器上注册成一个临时节点。

zookeeper拥有两种形式的节点，一种是临时节点，一种是永久节点。

注册成临时节点后，再服务端出问题时，节点会自动的从zookeeper上删除，

如此zookeeper服务器上的列表就是最新的可用的列表。

　客户端在需要访问服务器的时候首先会去Zookeeper获得所有可用的服务端的连接信息。
　客户端通过一定的策略（如随机）选择一个与之建立连接。
　当客户端发现连接不可用时，会再次从zookeeper上获取可用的服务端连接，
并同时删除之前获取的连接列表。



（3）命名服务

　提供名称的服务。使用较多的有两种id，一种是数据库自增长id，一种是UUID，

两种id都有局限，自增长id仅适合在单表单库中使用，uuid适合在分布式系统中使用但由于id没有规律难以理解。

而ZK提供了一定的接口可以用来获取一个顺序增长的，可以在集群环境下使用的id。



（4）分布式协调，通知，心跳服务

　在分布式服务系统中，判断服务可用，

传统的方式是通过ping主机来实现的，ping得200的结果说明说明该服务是OK的。

使用zookeeper时，服务注册成临时节点，只判断这个节点是否在zookeeper集群中存在就可以了，

不需要直接去连接和ping服务所在主机，减少系统的复杂度和对服务主机的压力。







### **1. 数据发布/订阅**

#### 介绍

数据发布/订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。

#### 目的

- 动态获取数据（配置信息）
- 实现数据（配置信息）的集中式管理和数据的动态更新

设计模式

- Push 模式
- Pull 模式

数据（配置信息）特性

- 数据量通常比较小
- 数据内容在运行时会发生动态更新
- 集群中各机器共享，配置一致

如：机器列表信息、运行时开关配置、数据库配置信息等

#### 基于Zookeeper的实现方式

- 数据存储：将数据（配置信息）存储到Zookeeper上的一个数据节点
- 数据获取：应用在启动初始化节点从Zookeeper数据节点读取数据，并在该节点上注册一个数据变更Watcher
- 数据变更：当变更数据时，更新Zookeeper对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。

### **2. 负载均衡**

zk的命名服务
命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。

分布式通知和协调
对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。
对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。



### **3.zk的命名服务（文件系统）**


命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。



### **4.zk的配置管理（文件系统、通知机制）**


程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。



### **5.Zookeeper集群管理（文件系统、通知机制）**

**
**

所谓集群管理无外乎两点：是否有机器退出和加入、选举master。
对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。
新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。



### 6.Zookeeper分布式锁（文件系统、通知机制）


有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。
对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。
对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次获取。



### **7.获取分布式锁的流程**



clipboard.png

在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，
然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。
clipboard.png

代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper实现分布式锁的细节。



### **8.Zookeeper队列管理（文件系统、通知机制）**



两种类型的队列：
1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。
2、队列按照 FIFO 方式进行入队和出队操作。
第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。