```shell
1、什么是消息的可靠性投递
   可靠性投递的目标
      保障消息成功发出
      保障MQ成功接收
      生产者接收到MQ的响应（Confirm）
      完善的消息补偿机制（ACK，比如消费了消息，但是突然宕机，消息丢失（没用到就是丢失））
   
   可靠性投递的方案
      
   
2、可靠性投递的四个确保
   确保消息发送到RabbitMQ服务器（exchange）
      1、事务模式transaction
         这种模式可以做到完全回滚，统一提交，但是不推荐，为什么？
      2、确认模式confirm
         比事务模式性能更好，同时大批数据提交MQ的时候，不会因为极个别数据失败而全部回滚
            
   确保消息路由到正确的队列
      产生原因：routing key错误或者队列不存在，消息发送给exchange之后，exchange不能将
      消息路由到对应的队列
      
      return消息机制
            通过配置mandatory为true，可以将发送到queue失败的response通过ReturnListener
            回调打印，接下来通过业务代码重发
      备份交换机（exchange）
         当目标交换机不能将消息路由到对应的队列，消息会进入备份交换机，走备份交换机的逻辑
   
   确保消息在队列持久化存储   
         交换机，队列，消息都可以进行持久化操作（写入磁盘）
         
   确保消费者成功消费消息
      在comsumer中回调中，先处理完业务代码，然后在调用chanel.basicAck
   
3、可靠性投递其他补充

   消费者回调：完整的流程应该是消息对比的方式
            简单处理可以参照微信支付通知回调的方式（生产者提供一个通知接口给消费者）
            需要一个唯一的messageID作为参数
   
   消费者补偿机制：可以通过重试来请求消费

   消息幂等性：
      生产者发送消息的时候设置messageId（注意唯一，uuid，雪花算法）
      消费者消费之后将该messageId保存起来（redis）
      当同样messageId的消息再次被监听到之后，将messageId和redis中的对比
      如果一样，chanel.basicNack(第三个参数要使用false，从队列中移除)

   消息顺序性
      需求:生产者发送的消息入列顺序为：A,B,C
            如果只有一个消费者，那消费的顺序为A,B,C
            如果有多个消费者，那么因为消费者的处理速度不一样，可能顺序就不是A,B,C
            你最终也只能化解为1对1消费
      
      消息顺序和性能是无法同时满足的，所以一般来说使用单一职责的消息队列让一个消费者消费即可
   
```

