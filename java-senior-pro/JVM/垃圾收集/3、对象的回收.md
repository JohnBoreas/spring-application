#### 一、对象的死亡

##### （1）真正宣告一个对象死亡，至少要经历两次标记过程：

​		可达性分析没有与GCRoots相连接的引用链，被第一次标记，

​		二次筛选，条件是此对象是否有必要执行finalize()方法。



假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。



##### （2）对象自救：

```
1.对象覆写了finalize()方法（这样在被判死后才会调用此方法，才有机会做最后的救赎）；
2.在finalize()方法中重新引用到"GC  Roots"链上（如把当前对象的引用this赋值给某对象的类变量/成员变量，重新建立可达的引用）.
```

注意：

finalize()只会在对象内存回收前被调用一次

finalize()的调用具有不确定性，只保证方法会调用，但不保证方法里的任务会被执行完







#### 二、方法区的垃圾收集

##### （1）主要回收

废弃的常量

不再使用的类型



##### （2）回收常量

已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量



##### （3）回收类型

要判定一个类型是否属于“不再被使用的类”的条件： 

```
·该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 

·加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 

·该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
```







