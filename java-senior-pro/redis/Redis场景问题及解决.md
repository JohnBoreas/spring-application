问题：

```
分布式数据缓存(Redis)   
关系型数据库瓶颈与优化、ehcache和redis的对比？nosql的使用场景
Redis基本数据类型、比如map的使用场景？有什么优缺点？什么时候用map等等
Redis高级特性、如何来理解redis的单线程但是高性能？如何理解redis和epoll
Redis持久化、什么情况下需要持久化？方案是什么？有什么优缺点？如何优雅的选择持久化方案
Redis项目中应用、reids的高级命令mget、scan？为什么有scan这条命令，如何理解redis的游标？
单机版redis的安装以及redis生产环境启动方案
redis持久化机对于生产环境中的灾难恢复的意义
redis主从架构下如何才能做到99.99%的高可用性
在项目中重新搭建一套主从复制+高可用+多master的redis cluster集群
redis在实践中的一些常见问题以及优化思路（包含linux内核参数优化）
redis的RDB持久化配置以及数据恢复实验
redis的RDB和AOF两种持久化机制的优劣势对比
```

**Redis 的并发竞争 Key 问题**

```
Redis 的并发竞争 Key 的问题：
	是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

首推Zookeeper。
```

**如何保证缓存与数据库双写时的数据一致性？**

```
只要用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性的问题

如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。
```



