#### 一、redis是什么

Redis：REmote DIctionary Server(远程字典服务器)

是完全开源免费的，用C语言编写的，遵守BSD协议，
是一个高性能的(key/value)分布式内存数据库，基于内存运行
并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,
也被人们称为数据结构服务器

##### Redis 与其他 key - value 缓存产品有以下三个特点：

```
1、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用

2、Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储

3、Redis支持数据的备份，即master-slave模式的数据备份
```



#### 二、能干嘛

1、内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务

2、取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面

（存储热点数据）

3、模拟类似于HttpSession这种需要设定过期时间的功能

4、发布、订阅消息系统

5、定时器、计数器



#### 三、一些概念

**Redis单点吞吐量**

```
单点TPS达到8万/秒，QPS达到10万/秒
```

**TPS和QPS的概念:**

```
1.QPS: 应用系统每秒钟最大能接受的用户访问量
每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。
2.TPS： 每秒钟最大能处理的请求数
每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。
```

**Redis持久化机制：RDB和AOF**

```
保证 redis 挂掉之后再重启数据可以进行恢复
    快照（snapshotting，RDB）
    只追加文件（append-only file,AOF）
1）RDB:
	默认开启，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。快照可备份，可移到其他服务器
2）AOF：
	默认不开启，以日志的形式记录每个写操作（读操作不记录），默认的文件名是appendonly.aof，只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。
appendonly yes
【参数：】
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步

AOF 重写
```

**Redis有哪些适合的场景？**

```powershell
1）Session共享(单点登录)
2）页面缓存
3）队列
4）排行榜/计数器
5）发布/订阅
```

**Key过期更新策略**

```powershell
定期删除+惰性删除。
定期删除 ：redis默认是每隔 100ms 随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除
	redis 存了几十万个key，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
	定期删除可能会导致很多过期 key 到了时间并没有被删除掉。
惰性删除 ：定期删除未删的key，下次查到判断是否过期，过期删除掉
```

**redis 提供 6种数据淘汰策略：**

```powershell
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。
```

**redis 事务**

```
Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。

事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。
```

**缓存雪崩和缓存穿透**

```
【缓存雪崩】
简介：
	缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决办法：
>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
>事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
>事后：利用 redis 持久化机制保存的数据尽快恢复缓存

【缓存穿透】
简介：
	故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决办法： 
	最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
	另一种，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
```

**哨兵模式**（2.8版本或更高）

```
1.三个定时监控任务：

1.1 每隔10s，每个S节点（哨兵节点）会向主节点和从节点发送info命令获取最新的拓扑结构
1.2 每隔2s，每个S节点会向某频道上发送该S节点对于主节点的判断以及当前Sl节点的信息，
同时每个Sentinel节点也会订阅该频道，来了解其他S节点以及它们对主节点的判断（做客观下线依据）
1.3 每隔1s，每个S节点会向主节点、从节点、其余S节点发送一条ping命令做一次心跳检测(心跳检测机制)，来确认这些节点当前是否可达

2.主客观下线：

2.1主观下线：根据第三个定时任务对没有有效回复的节点做主观下线处理
2.2客观下线：若主观下线的是主节点，会咨询其他S节点对该主节点的判断，超过半数，对该主节点做客观下线

3.选举出某一哨兵节点作为领导者，来进行故障转移。选举方式：raft算法。每个S节点有一票同意权，哪个S节点做出主观下线的时候，就会询问其他S节点是否同意其为领导者。获得半数选票的则成为领导者。基本谁先做出客观下线，谁成为领导者。

4.故障转移
```

