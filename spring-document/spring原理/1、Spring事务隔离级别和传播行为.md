事务隔离级别

DEFAULT ：使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 .

READ_UNCOMMITTED ：会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )

READ_COMMITTED ：会出现不可重复读、幻读问题（锁定正在读取的行）

REPEATABLE_READ ：会出幻读（锁定所读取的所有行）

SERIALIZABLE ：保证所有的情况不会发生（锁表）



事务的7种传播级别：

1） **PROPAGATION_REQUIRED** ，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。

默认的spring事务传播级别，这个级别通常能满足处理大多数的业务场景。

2）**PROPAGATION_SUPPORTS** ，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。

所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。

3）**PROPAGATION_MANDATORY** ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！

配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。

4）**PROPAGATION_REQUIRES_NEW** ，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。

这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。
怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。

5）**PROPAGATION_NOT_SUPPORTED** ，非事务地执行，上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。

这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。

6）**PROPAGATION_NEVER** ，非事务地执行，要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，

强制停止执行！这个级别上辈子跟事务有仇。

7）**PROPAGATION_NESTED** ，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。

nested，嵌套级别事务