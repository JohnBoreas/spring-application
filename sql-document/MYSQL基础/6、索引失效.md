索引失效原因

##### 一、查询条件包含or，可能导致索引失效

```SQL
// 走security_code的索引
SELECT * from tb_org_num WHERE security_code = '000008'
// 未走索引
SELECT * from tb_org_num WHERE security_code = '000008' OR report_date = '2021-06-30'
```



##### 二、如何字段类型是字符串，where时一定用引号括起来，否则索引失效

```SQL
// 走security_code的索引
SELECT * from tb_org_num WHERE security_code = '000008'
// 未走索引
SELECT * from tb_org_num WHERE security_code = 000008
```

不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做**隐式的类型转换**，把它们转换为浮点数再做比较



##### 三、like通配符可能导致索引失效

```sql
// 走security_code的索引
SELECT * from tb_org_num WHERE security_code like '000008%'
// 未走索引
SELECT * from tb_org_num WHERE security_code like '%000008%'
// 走security_code的索引
SELECT security_code,id from tb_org_num WHERE security_code like '%000008%'
```

like查询以%开头，会导致索引失效。可以有两种方式优化：

（1）使用覆盖索引

（2）把%放后面

附: 索引包含所有满足查询需要的数据的索引，称为覆盖索引(Covering Index)。



##### 四、联合索引，查询时的条件列不是联合索引中的第一个列，索引失效

```sql
// 走security_code的索引
SELECT * from tb_org_num WHERE security_code = '000008' AND report_date = '2021-06-30'
// 未走索引
SELECT * from tb_org_num WHERE report_date = '2021-06-30'
```

**分析与结论：**

- 当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。
- 联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。



##### 五、在索引列上使用mysql的内置函数，索引失效



##### 六、对索引列运算（如，+、-、*、/），索引失效



##### 七、索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效



##### 八、索引字段上使用is null， is not null，可能导致索引失效



##### 九、左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效



##### 十、mysql估计使用全表扫描要比使用索引快,则不使用索引

<img src="..\resource\SQL解析流程.awebp" alt="img" style="zoom:60%;" />



（1）查询的数据过多

（2）字段频繁更新

（3）