【一、工作中遇到的问题】

（1）id生成策略

【问题】：ID自增

1）ID自增

1.自增，趋势自增，可作为聚集索引，提升查询效率

2.节省磁盘空间。500W数据，UUID占5.4G,自增ID占2.5G.

3.查询，写入效率高：查询略优。写入效率自增ID是UUID的四倍。

2）缺点：

1.导入旧数据时，可能会ID重复，导致导入失败。

2.分布式架构，多个Mysql实例可能会导致ID重复。

【id生成策略】：

1）id自增

》单点问题，分表分库不能保证id唯一；

》自增锁(AUTO_INC锁)，大量的并发插入，表锁会引起SQL堵塞

2）UUID

》优点：没有自增锁的问题，也没有单点问题，实现简单。

》问题：由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上

3）维护一个Sequence表

优点：没有自增锁问题。

问题：所有插入都需要访问该表，容易成为系统瓶颈，存在单点问题

解决：使用Master-Slave进行主从同步，只能解决单点问题，不能解决访问压力问题。

4）twitter的snowflake算法

使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID

【总结】：

1.单实例，单节点，由于InnoDB的特性，自增ID效率大于UUID.

2.20个节点一下小型分布式架构：为了实现快速部署，主键不重复，可以采用UUID

3.20到200个节点：可以采用自增ID+步长的较快速方案。

4.200个以上节点的分布式架构：可以采用twitter的雪花算法全局自增ID

（2）ID自增严重

【ID自增严重】

（1）原因：

REPLACE INTO ...：插入的时候如果唯一索引对应的数据已经存在，会删除原数据，重新插入新的数据

INSERT ... ON DUPLICATE KEY UPDATE ...对主键的影响

INSERT ignore into

（2）mysql的自增：INSERT ... ON DUPLICATE KEY UPDATE ...

innodb_autoinc_lock_mode：mysql主键自增参数，值为0，1，2，mysql5.1后加入的，默认值是1

1）当做简单插入（可以确定插入行数）的时候，直接将auto_increment加1，而不会去锁表，这也就提高了性能。

2）复杂语句时不知道插入行数，会锁表AUTO_INC

3）innodb_autoinc_lock_mode = 1，预先就可以计算出影响的行数，所以不管是否更新，这里都将auto_increment加1（多行的话大于1）。

4）innodb_autoinc_lock_mode = 0，auto_increment并没有增加，这种模式直接加了AUTO_INC锁，执行完语句的时候释放，发现没有增加行数的话，不会增加自增id的。

5）插入影响1行，更新影响2行，0的话就是存在且更新前后值一样













【一、建表注意事项】

（1）重要的字段放在前面

（2）命名，要能通过名字清楚的知道含义

（3）空：看那些字段是否必须为非空，那些是不必为null的，如：价格

（4）唯一索引：通过多个字段去唯一得到数据，根据某个字段得到一份数据（结合实际）

（5）createtime：看需要哪种类型，int，datetime

（6）索引：

1）唯一索引，看需求

2）updatetime：看是否需要，根据更新时间查

（7）fetchtime：抓取时间，区别于updatetime，createtime，看是否需要

（8）字段长度：id一般选bitint，其他看是否合适

（9）所有的字段要加commet注释

（10）int 符号确定：确定整形为非负数，就将int设置为无符号型的，即int unsigned，可以多一半的值范围，又能避免插入负数。int设置为无符号的场景在很多场合都使用。

（11）不定长varchar的长度设置：对于不定长字符串varchar如果不确定字符串长度（且知道字符串长度小于255）可以设置为vachar(255)，此时，存储空间只比正常的多一个字节（与设置varcahr(10)额外存储的空间是一样的），又能够最大限度的利用varchar的特定。注意：超过255则用于存储该长度的空间会多于一个字节。

（12）有限状态的类型设置：对于表示状态数值的数据类型建议设置为tinyint unsigned（只占用一个字节的空间） 可以表示0到255的范围。注意：无需用int，占用四个字节的空间。

（13）字段尽量加上字段创建时间ctime和字段修改时间mtime，便于后期排查问题，知道该条记录是何时插入，何时修改。

（14）日期时间设置为int时的查询，用的是unix时间戳来存储，但是不能设置缺省值

（15）尽可能的设置default的值，比如：app_name 中通过设置default ‘’，click_cnt设置default ‘0’。

例子：

![img](..\resource\cb9223cb28344a2c8137269cb1187b71.jpg)

【二、工作中遇到的常用】

（1）IFNULL(expr1,expr2) 

【Mysql函数】：如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr2。

【更新时候判空】：为空取原来的，不为空则更新

【作用】：防止插入字段为null报错，或者不希望更新null值进去

（2）查询两个表里的不相同数据

【SQL】：SELECT COUNT(bak.`item_id`) FROM tb_sqkb_api_items_bak bak

INNER JOIN tb_sqkb_api_items aa ON bak.`item_id` = aa.`item_id`;

【策略】：先查两个表相同的数据，在用两个表总数减去重复数

【优点】：两个表关联，用INNER JOIN，用索引更快

（3）TRUNCATE table

【作用】：删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。

【DROP】：如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

【DELETE】：DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。

【TRUNCATE TABLE】：通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（4）分表查询

拼接SQL，"INSERT INTO spider.item_" + sufTab + "

末尾的表tab通过唯一键取余得到，看分成几个表

【三、删表】

（1）表特别大，建议改表名，后慢慢删

- 硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块
- 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。

（2）通过id删