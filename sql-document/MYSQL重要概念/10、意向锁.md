#### 意向锁

`InnoDB`支持*多粒度锁定*，允许行锁和表锁共存。例如，诸如这样的语句 在指定的表上[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)获取了一个排他锁（一个锁）。`X`为了使多粒度级别的锁定变得实用，`InnoDB`请使用 [意图锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock)。

意向锁是表级锁，它指示事务稍后对表中的行需要哪种类型的锁（共享或独占）。有两种类型的意图锁：

- [意向共享锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock)( `IS`) 表示事务打算在表中的各个行上设置 共享 锁 *。*
- [意向排他锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock) ( `IX`)表示事务打算对表中的各个行设置排他锁。

例如，[`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)设置一个`IS`锁，并 [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)设置一个`IX`锁。

意图锁定协议如下：

- 在事务可以获取表中行的共享锁之前，它必须首先获取`IS`表上的锁或更强的锁。
- 在事务可以获取表中行的排他锁之前，它必须首先获取`IX` 表上的锁。

下面的矩阵总结了表级锁类型的兼容性。

|      | `X`  | `IX`   | `S`    | `IS`   |
| :--- | :--- | :----- | :----- | :----- |
| `X`  | 冲突 | 冲突   | 冲突   | 冲突   |
| `IX` | 冲突 | 兼容的 | 冲突   | 兼容的 |
| `S`  | 冲突 | 冲突   | 兼容的 | 兼容的 |
| `IS` | 冲突 | 兼容的 | 兼容的 | 兼容的 |

如果锁与现有锁兼容，则将锁授予请求事务，但如果与现有锁冲突则不会。事务等待直到释放冲突的现有锁。[如果锁请求与现有锁冲突并且由于会导致死锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock)而无法授予 ，则会发生错误。

[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)除了全表请求（例如， ） 之外，意图锁不会阻塞任何东西。意图锁的主要目的是表明有人正在锁定一行，或者要锁定表中的一行。

[意向锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 类似于以下内容：

```sql
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```

