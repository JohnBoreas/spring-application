#### 意向锁

`InnoDB`支持*多粒度锁定*，允许行锁和表锁共存。例如，诸如这样的语句 在指定的表上[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)获取了一个排他锁（一个锁）。`X`为了使多粒度级别的锁定变得实用，`InnoDB`请使用 [意图锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock)。

意向锁是表级锁，它指示事务稍后对表中的行需要哪种类型的锁（共享或独占）。有两种类型的意图锁：

- [意向共享锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock)( `IS`) 表示事务打算在表中的各个行上设置 共享 锁 *。*
- [意向排他锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock) ( `IX`)表示事务打算对表中的各个行设置排他锁。

例如，[`SELECT ... FOR SHARE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)设置一个`IS`锁，并 [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/8.0/en/select.html)设置一个`IX`锁。

意图锁定协议如下：

- 在事务可以获取表中行的共享锁之前，它必须首先获取`IS`表上的锁或更强的锁。
- 在事务可以获取表中行的排他锁之前，它必须首先获取`IX` 表上的锁。

下面的矩阵总结了表级锁类型的兼容性。

|      | `X`  | `IX`   | `S`    | `IS`   |
| :--- | :--- | :----- | :----- | :----- |
| `X`  | 冲突 | 冲突   | 冲突   | 冲突   |
| `IX` | 冲突 | 兼容的 | 冲突   | 兼容的 |
| `S`  | 冲突 | 冲突   | 兼容的 | 兼容的 |
| `IS` | 冲突 | 兼容的 | 兼容的 | 兼容的 |

如果锁与现有锁兼容，则将锁授予请求事务，但如果与现有锁冲突则不会。事务等待直到释放冲突的现有锁。[如果锁请求与现有锁冲突并且由于会导致死锁](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_deadlock)而无法授予 ，则会发生错误。

[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html)除了全表请求（例如， ） 之外，意图锁不会阻塞任何东西。意图锁的主要目的是表明有人正在锁定一行，或者要锁定表中的一行。

[意向锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 类似于以下内容：

```sql
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```





#### 插入意向锁

插入意图锁是一种 [`INSERT`](https://dev.mysql.com/doc/refman/8.0/en/insert.html)在行插入之前由操作设置的间隙锁。这个锁表示插入的意图，这样插入到同一个索引间隙中的多个事务如果没有插入到间隙中的相同位置，则不需要相互等待。假设有值为 4 和 7 的索引记录。分别尝试插入值 5 和 6 的单独事务，在获得对插入行的排他锁之前，每个事务都使用插入意向锁锁定 4 和 7 之间的间隙，但不要互相阻塞，因为这些行是不冲突的。

以下示例演示了一个事务在获取插入记录的独占锁之前获取插入意向锁。该示例涉及两个客户端 A 和 B。

客户端A创建了一个包含两条索引记录（90和102）的表，然后启动一个事务，在ID大于100的索引记录上放置排他锁。排他锁包括记录102之前的间隙锁：

```sql
mysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;
mysql> INSERT INTO child (id) values (90),(102);

mysql> START TRANSACTION;
mysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+
```

客户端 B 开始事务以将记录插入间隙。事务在等待获得独占锁时获取插入意向锁。

```sql
mysql> START TRANSACTION;
mysql> INSERT INTO child (id) VALUES (101);
```

[插入意向锁的事务数据在InnoDB 监视器](https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html) 输出 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/8.0/en/show-engine.html)中 类似于以下内容 ：

```sql
RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; asc    f;;
 1: len 6; hex 000000002215; asc     " ;;
 2: len 7; hex 9000000172011c; asc     r  ;;...
```