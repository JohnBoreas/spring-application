一、死锁数据库死锁

在多进程中同时insert数据，唯一索引问题导致死锁

* 死锁产生的原因：

（1）系统资源不足。（2） 进程运行推进的顺序不合适。（3）资源分配不当等。

* 死锁产生的必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。





**二、HashSet 再线程不安全下使用**

1、起因：在java1.7下使用HashSet 作为缓存做过滤设备号（百万级），并使用了多线程

2、现象：程序在跑一段时间后会假死掉，所有线程都报错，HashSet 相关的错误

3、原因：多个线程并发的操作，由于 HashSet 其实本质上就是 HashMap，是线程不安全的，会出现两个问题：

```
jdk1.7下：
1、Set 中的数据在并发写入时被覆盖导致数据不准确。
2、会在扩容的时候形成环形链表。
```

4、HashMap的一些特性

HashMap就是一个散列表，是基于哈希表的Map接口实现，它存储的内容是键值对 (key-value) 映射，并且键值允许为null(键的话只允许一个为null)

①根据键的hashCode存储数据。

②HashMap的存储单位是Node<k,v>,可以认作为节点

③Hashmap中的扩容的个数是针对size(内部元素(节点)总个数)，而不是数组的个数

| 特征                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| 是否允许重复数据    | key如果重复会覆盖，value允许重复                             |
| hashMap是否有序     | 无序，这里的无序指的是遍历HashMap的时候，得到的顺序大都跟put进去的顺序不一致 |
| hashMap是否线程安全 | 非线程安全，因为里面的实现不是同步的，如果想要线程安全，推荐使用 |
| 键值是否允许为空    | key和value都允许为空，但只允许一个为空                       |

5、原因：扩容

```java
	因为在hashmap中使用了hash表，每次hash冲突时，会将元素放入链表中，随着插入越来越多，hash表因为容量问题，会不断扩容，并重新计算hashcode值，新生成一个数组，然后拷贝旧数组里面的每一个Node链表到新数组里面，
	这个方法在单线程下执行是没有任何问题的，但是在多线程下，基于头插法的数据迁移，会有几率造成链表倒置，从而引发链表闭链，在遍历链表，同时由于形成了环形链表导致这个 e.next 永远不为空，所以这个循环也不会退出了，导致程序死循环，并吃满CPU
void transfer(Entry[] newTable) {    
    Entry[] src = table;                   //src引用了旧的Entry数组    
    int newCapacity = newTable.length;    
    for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组    
        Entry<K, V> e = src[j];             //取得旧Entry数组的每个元素    
        if (e != null) {    
            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）   
            do {    
                Entry<K, V> next = e.next;    
                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置    
                e.next = newTable[i]; //标记[1]    
                newTable[i] = e;      //将元素放在数组上    
                e = next;             //访问下一个Entry链上的元素    
            } while (e != null);    
        }    
    }
}
```

三、synchronized的使用导致cpu升高

1、背景：在多线程中使用synchronized对list进行加锁，多生产者-消费者模式，程序cpu忽高忽低

2、原因：

​		synchronized在1.7后有所优化，有偏向锁，轻量级锁，重量级锁之分，锁只能升级不能降级，在多线程中每次取list中的数据时，都会加锁，但是很快释放掉，进入轻量级锁，其他线程自旋循环方式获取锁，导致cpu增高（推测）



四、ConcurrentHashMap长度过长情况下，多线程会卡住的问题

长度过长cpu会很高，可能是因为内存不足原因导致



