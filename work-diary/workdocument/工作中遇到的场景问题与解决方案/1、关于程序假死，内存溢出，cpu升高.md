1、程序假死

（1）通过平台查看程序，发现没有日志，但是程序是活的

（2）使用jstack查看程序dump信息

（3）注意到cousmerThread发生异常，生产者，数据库线程等待，判断是消费者的问题

但是，一般情况下是会做异常处理的，并且消费者线程还是存活的

（4）然后注意到是对方包的问题，应该是HttpURLConnection请求后一直等待，卡死，HttpURLConnection未设置超时时间

解决：

不用第三方包



2、cpu升高

（1）原因：

- Full GC次数过多；
- 代码中有比较耗CPU的操作，比较耗时的计算，导致CPU过高；

（2）定位是哪个线程高

Top –Hp PID

Printf ‘%x\n’ PID

（3）查看线程的堆栈信息

Jstack PID | grep tid –A line

（4）观察GC次数

jstat -gcutil 9 1000 10

（5）解决：

调整xms与xmx大小



3、如何调整xms与xmx

xms与xmx设置成一样，根据FullGc日志观察，设定合适的大小

具体来讲：

```
Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍
永久代 PermSize和MaxPermSize设置为老年代存活对象的1.2-1.5倍。
年轻代Xmn的设置为老年代存活对象的1-1.5倍。
老年代的内存大小设置为老年代存活对象的2-3倍。
```

BTW：

```
1、Sun官方建议年轻代的大小为整个堆的3/8左右， 所以按照上述设置的方式，基本符合Sun的建议。
2、堆大小=年轻代大小+年老代大小， 即xmx=xmn+老年代大小 。 Permsize不影响堆大小。
3、为什么要按照上面的来进行设置呢？ 没有具体的说明，但应该是根据多种调优之后得出的一个结论。
```

