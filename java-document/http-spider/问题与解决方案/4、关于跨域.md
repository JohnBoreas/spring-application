Greasemonkey中请求api时候涉及跨域问题

只向服务器传送数据

```js
$.ajax({
    type: "POST",
    url: url,
    data: {title: title, msg: msg}
});
```

get服务器数据

```js
$.post(url, {"data": data}, function (resp) {
    if (resp.status == 1) {
        console.log();
    }
});
```



一、什么是跨域？

**跨域：跨域访问，简单来说就是 A 网站的 javascript 代码试图访问 B 网站，包括提交内容和获取内容。由于安全原因，跨域访问是被各大浏览器所默认禁止的，**XmlHttpRequest也不例外。



有三个标签是允许跨域加载资源：

- <img src=XXX />

- <link href=XXX />

- <script src=XXX />



二、解决：

主要是服务器来解决跨域问题，js分别使用上面的请求方式

（1）jsonp

1、原理

jsonp可以说是非官方跨域数据交互协议，只能用get请求

**允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。**

​		相当于，ajax请求接口，返回一串callback() 包好的json数据，然后jquery会生成一个 callback() 的函数，可以供js调用

```js
// 示例
<script type="text/javascript">
function callback(data) {// 回调函数
    alert(data.message);
}
</script>
// callback({message:"success"});
<script type="text/javascript" src="http://localhost:api/api"></script>

// 前端js调用示例
$.ajax({
	url: url,
	type: 'GET',
	dataType: 'JSONP',// 重点在这里，加上这个属性就可以跨域请求了
	success: function (data) {
	}
});

 // 添加<script>标签的方法
function addScriptTag(src) {
    var script = document.createElement('script');
    script.setAttribute("type", "text/javascript");
    script.src = src;
    document.body.appendChild(script);
}
```

注意：

如果没有成功，console会报callback方法不存在的错误，但是数据是请求了，可能需要换用post去请求



（2）Node中间件代理(两次跨域)

1、实现原理：

**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**

2、代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。

<img src="../..\resource\Nginx跨域.png" alt="img" style="zoom:77%;" />

```js
/* 代理服务器http://localhost:3000 */
const http = require('http')
// 第一步：接受客户端请求
const server = http.createServer((request, response) => {
  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段
  response.writeHead(200, {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': 'Content-Type'
  })
  // 第二步：将请求转发给服务器
  const proxyRequest = http.request({
        host: '127.0.0.1',
        port: 4000,
        url: '/',
        method: request.method,
        headers: request.headers
      },
      serverResponse => {
        // 第三步：收到服务器的响应
        var body = ''
        serverResponse.on('data', chunk => {
          body += chunk
        })
        serverResponse.on('end', () => {
          console.log('The data is ' + body)
          // 第四步：将响应结果转发给浏览器
          response.end(body)
        })
     }).end()
})
server.listen(3000, () => {
  console.log('The proxyServer is running at http://localhost:3000')
})
// server2.js(http://localhost:4000)
const http = require('http')
const data = { title: 'fontend', password: '123456' }
const server = http.createServer((request, response) => {
  if (request.url === '/') {
    response.end(JSON.stringify(data))
  }
})
server.listen(4000, () => {
  console.log('The server is running at http://localhost:4000')
})
```



（3）CORS 

需要浏览器和后端同时支持

1、原理

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。



在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

2、简单请求

条件1：使用下列方法之一：

- GET
- HEAD
- POST

条件2：Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

3、复杂请求

不符合以上条件的请求就肯定是复杂请求了。

复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。