###### （1）生成器模式（建造者模式）

优点：

将一个对象分解为各个组件

将对象组件的构造封装起来

可以控制整个对象的生成过程

缺点：

对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量

定义：封装一个复杂对象构造过程，并允许按步骤构造。

* 区别工厂模式：

生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤；

工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。

* 包括四种角色：

（1）产品(Product)：具体生产器要构造的复杂对象；

（2）抽象生成器(Bulider)：抽象生成器是一个接口，该接口除了为创建一个Product对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法；

（3）具体生产器(ConcreteProduct)：实现Builder接口的类，具体生成器将实现Builder接口所定义的方法；

（4）指挥者(Director)：指挥者是一个类，该类需要含有Builder接口声明的变量。指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的Product对象，如果所请求的具体生成器成功地构造出Product对象，指挥者就可以让该具体生产器返回所构造的Product对象。

```java
// 抽象生成器(Bulider)
public abstract class ComputerBuilder {
    protected Computer computer;
    public Computer getComputer() {
        return computer;
    }
    public void buildComputer() {
        computer = new Computer();
        System.out.println("生成了一台电脑！！！");
    }
    public abstract void buildMaster();
    public abstract void buildScreen();
    public abstract void buildKeyboard();
    public abstract void buildMouse();
    public abstract void buildAudio();
}
// 具体生产器(ConcreteBuilder)
public class HPComputerBuilder extends ComputerBuilder {
    @Override
    public void buildMaster() {
        computer.setMaster("i7,16g,512SSD,1060");
    }
    @Override
    public void buildScreen() {
        computer.setScreen("1080p");
    }
    @Override
    public void buildKeyboard() {
        computer.setKeyboard("cherry 青轴机械键盘");
    }
    @Override
    public void buildMouse() {
        computer.setMouse("MI 鼠标");
    }
    @Override
    public void buildAudio() {
        computer.setAudio("飞利浦 音响");
    }
}
// 指挥者(Director)
public class Director {
   
    private ComputerBuilder computerBuilder;
    public void setComputerBuilder(ComputerBuilder computerBuilder) {
        this.computerBuilder = computerBuilder;
    }
   
    public Computer getComputer() {
        return computerBuilder.getComputer();
    }
   
    public void constructComputer() {
        computerBuilder.buildComputer();
        computerBuilder.buildMaster();
        computerBuilder.buildScreen();
        computerBuilder.buildKeyboard();
        computerBuilder.buildMouse();
        computerBuilder.buildAudio();
    }

```



###### （2）原型模式

定义：通过复制现有实例来创建新的实例，无需知道相应类的信息。

角色：

Client：使用者

Prototype：接口（抽象类），声明具备clone能力，例如java中得Cloneable接口

ConcretePrototype：具体的原型类

![](../resource/原型模式的结构.png)

* 深拷贝和浅拷贝

浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。

深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的



**原型模式的本质就是clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。**

```java
/**
 * 序列化方式深拷贝（需要Object继承Serializable）
 * @param t
 * @return
 * @throws IOException
 * @throws ClassNotFoundException
 */
public static Object serializationDeepCopy(Object t) throws IOException, ClassNotFoundException {
    //通过序列化方法实现深拷贝
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(t);
    oos.flush();
    ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
    return ois.readObject();
}
/**
 * 具体原型（Concrete Prototype）
 */
public class ConcretePrototypeA implements Cloneable, Serializable {
    public String name;
    public double length;
    ConcretePrototypeA(String name, double length){
        this.name = name;
        this.length = length;
    }
    public Object clone() throws CloneNotSupportedException {
        ConcretePrototypeA object = (ConcretePrototypeA) super.clone();
        return object;
    }
    public String toString() {
        return name + ", " + length;
    }
}
```



###### （3）适配器模式（Adapter Pattern）

定义： 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

































