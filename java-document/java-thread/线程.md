

（3）多线程：

```
线程是进程内的执行单元，多线程是这个程序（一个进程）运行时产生了不止一个线程
```

（3）并行与并发：

```shell
并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
并发：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。

`并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。`
```

（4）同步与异步

```shell
同步：指的发出一个调用时，如果没有得到结果就不返回，直到有结果后再返回。
异步：指的是发出一个调用时就立即返回而不在乎此时有没有结果。
```

（5）线程安全

```
指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。
一个对象被多个线程同时访问，还能保持其内部属性的顺序性及同步性，则认定为线程安全
```







#### 4、

happens-before、内存屏障、编译器指令重排和 CPU 指令重
volatile 的实现原理
volatile 和原子性、可见性和有序性之间的关系
有了 symchronized 为什么还需要 volatile
不使用synchronized如何实现一个线程安全的单例





#### 5、线程的一些概念



→ sleep 和 wait
→ wait 和 notify
→ notify 和 notifyAll

守护线程
守护线程和非守护线程的区别以及用法

→ 什么是线程，与进程的区别
线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程
线程与进程的区别

#### 6、线程池

自己设计线程池、submit() 和 execute()、线程池原理
为什么不允许使用 Executors 创建线程池



→ ThreadLocal
→ 写代码来解决生产者消费者问题
→ 并方包
写代码来解决生产者消费者问题





**什么是上下文切换?**

背景：一个 CPU 核心在任意时刻只能被一个线程使用

目的：为了执行更有效率

策略：CPU 采取的策略是为每个线程分配时间片并轮转的形式

一次上下文切换：当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

上下文切换通常是计算密集型的。

时间：纳秒级

上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。