#### 1、线程的基本概念
（1）线程状态转化
![线程状态转化](../resource/线程状态转化.png)

（2）多线程：

```
线程是进程内的执行单元，多线程是这个程序（一个进程）运行时产生了不止一个线程
```

（3）并行与并发：

```shell
并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
并发：指两个或多个事件在同一时间间隔内发生，即交替做不同事的能力，通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。

`并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。`
```

（4）同步与异步

```shell
同步：指的发出一个调用时，如果没有得到结果就不返回，直到有结果后再返回。
异步：指的是发出一个调用时就立即返回而不在乎此时有没有结果。
```

（5）线程安全

```
指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。
一个对象被多个线程同时访问，还能保持其内部属性的顺序性及同步性，则认定为线程安全
```



#### 2、线程安全

什么是线程安全？

（1）如何保证线程安全？

```shell
①原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized，lock，atomic类）；
②可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
③有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。
可以通过volatile、synchronized、lock保证有序性。
```

（2）线程安全级别

```shell
①不可变的——也就是有final修饰的类，例如String、Long，它们就不用外部同步。
②无条件的线程安全——这个类没有final修饰，但其内部已经保证了线程安全，例如并发包中的并发集合类，同样它们无需外部同步。
③有条件的线程安全——这个有的方法需要外部同步，而有的方法则和“无条件的线程安全”一样无需外部同步。
④非线程安全——这就是最“普通”的类了，内部的任何方法想要保证安全性就必须要外部同步。
```

→ 线程安全
死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系



1、什么是线程安全

2、如何确保线程安全

3、线程安全的实现



（1）线程安全

“线程安全”也不是指线程的安全，而是指内存的安全。

进程：为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。

堆（内存）：每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，进程中的公共变量都在堆里

栈内存：操作系统会为每个线程分配属于它自己的内存空间，局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道



保证线程安全：

1、每个线程里都copy一份数据：

ThreadLocal就是，把一个数据复制N份，每个线程在运行时都会拷贝一份存储到自己的本地，互不影响。

2、只能读取，不能修改。

其实就是常量或只读变量，final

3、数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。局部变量

4、并发量大，变量需要多个线程操作时，使用锁

为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。相当于悲观锁

Lock、synchronize

5、在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS

在修改前检查，被修改后替换，相当于乐观锁





#### 4、volatile

（1）实现原理

```shell
1、基于内存屏障（Memory Barrier），禁止重排序。

## 内存屏障，是一个 CPU 指令
为了提高执行性能，编译器和处理器会对指令进行重排序
JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序

## 特性
1）一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。基于内存屏障来实现（实现可见性）
2）禁止进行指令重排序。（实现有序性）
3）只能保证对单次读/写的原子性。i++ 这种操作不能保证原子性。（原子性）

## 内存语义
1）当线程对volatile变量进行写操作时，会将修改后的值刷新回主内存
2）当线程对volatile变量进行读操作时，会先将自己工作内存中的变量置为无效，之后再通过主内存拷贝新值到工作内存中使用。

```

![读插入内存屏障](../resource/volatile 读插入内存屏障.png)      ![](../resource/volatile 写插入内存屏障.png)

（2）happens-before原则：

```shell
## 即：JMM具有先天的有序性，即不需要通过任何手段就可以得到保证的有序性。
1.程序次序规则：在一个单独的线程中，按照程序代码书写的顺序执行。
2.锁定规则：一个unlock操作happen—before后面对同一个锁的lock操作。
3.volatile变量规则：对一个volatile变量的写操作happen—before后面对该变量的读操作。
4.线程启动规则：Thread对象的start()方法happen—before此线程的每一个动作。
5.线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
6.线程中断规则：对线程interrupt()方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。
7.对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize()方法的开始。
8.传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。
```

（3）Synchronized与volatile区别

```gfm
1.volatile只能修饰变量，而synchronized可以修改变量，方法以及代码块
2.volatile在多线程中不会存在阻塞问题，synchronized会存在阻塞问题
3.volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性
4.volatile解决的是变量在多个线程之间的可见性，而sychroized解决的是多个线程之间访问资源的同步性
```

（4）应用场景

```shell
## 使用条件
访问变量不需要加锁（加锁的话使用volatile就没必要了）
对变量的写操作不依赖于当前值。
该变量没有包含在具有其他变量的不变式中。

只有在状态真正独立于程序内其他内容时才能使用 volatile。
```

（5）应用

```java
## 双重检查（double-checked）
class Singleton {
    private volatile static Singleton instance;
    public static Singleton getInstance() {
        if (instance == null) {
            syschronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    } 
}
```



happens-before、内存屏障、编译器指令重排和 CPU 指令重
volatile 的实现原理
volatile 和原子性、可见性和有序性之间的关系
有了 symchronized 为什么还需要 volatile
不使用synchronized如何实现一个线程安全的单例

#### 5、线程的一些概念

1、守护线程

​		把 Java 线程分成 2 类，一类是用户线程，也就是我们创建线程时，默认的一类线程，属性 daemon = false；另一类是守护线程，当我们设置 daemon = true 时，就是这类线程。

​		用户线程就是运行在前台的线程，守护线程就是运行在后台的线程，一般情况下，守护线程是为用户线程提供一些服务。

​		**当所有用户线程都执行完，只存在守护线程在运行时，JVM 就退出**。

```java
// 当非守护线程数量大于 1 时，就一直等待，直到剩下一个非守护线程时，就会在线程执行完后，退出 JVM。
bool Threads::destroy_vm() {
  JavaThread* thread = JavaThread::current();

#ifdef ASSERT
  _vm_complete = false;
#endif
  /**
   * 等待自己是最后一个非守护线程条件
   */
  // Wait until we are the last non-daemon thread to execute
  { MonitorLocker nu(Threads_lock);
    while (Threads::number_of_non_daemon_threads() > 1)
        /**
         * 非守护线程数大于 1，则一直等待
         */
      // This wait should make safepoint checks, wait without a timeout,
      // and wait as a suspend-equivalent condition.
      nu.wait(0, Mutex::_as_suspend_equivalent_flag);
  }

  /**
   * 下面代码是关闭 VM 的逻辑
   */
  EventShutdown e;
  if (e.should_commit()) {
    e.set_reason("No remaining non-daemon Java threads");
    e.commit();
  }
  ...... 省略余下代码
}
```

→ sleep 和 wait
→ wait 和 notify
→ notify 和 notifyAll

守护线程
守护线程和非守护线程的区别以及用法

→ 什么是线程，与进程的区别
线程的实现、线程的状态、优先级、线程调度、创建线程的多种方式、守护线程
线程与进程的区别

#### 6、线程池

自己设计线程池、submit() 和 execute()、线程池原理
为什么不允许使用 Executors 创建线程池



→ ThreadLocal
→ 写代码来解决生产者消费者问题
→ 并方包
写代码来解决生产者消费者问题

