概述：

把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并



时间：
$$
T（n）= k T(n/m) + f(n)
$$


##### 基本思想及策略

分治法的设计**思想**是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。



分治**策略**是：

**分** — 将大规模的原问题分割成 k 个更小规模的 **子问题**，如果子问题的规模仍然不够小，则再划分为 k 个“**子 子**”问题，如此**递归地**进行下去，直到子问题规模足够小（**基础问题**），很容易求出其解为止。

**治** — 求解规模足够小的**基础问题**。

**合** — 将求出的小规模的问题的解**合并**为一个更大规模的问题的解，**自底向上**逐步求出原来问题的解。



**三个阶段**： 

​		Divide 、 Conquer 、 Combine 。 

Divide 阶段是把原问题分割成小问题， 

Conquer 阶段是递归处理流程， 

Combine 阶段是运用小问题的答案合成出原问题的解答。



**两个原则**：

 **平衡子问题原则**，分割出的k个子问题其规模最好大致相当；

 **独立子问题原则**，分割出的k个子问题之间重叠越少越好，最好k个子问题是相互独立，不存在重叠子问题。



##### 模式

```c++
Divide-and-Conquer(P)
// |P|表示问题P的规模, n0为一阈值
if  ( | P | <= n0) {
	then return(ADHOC(P))
} else {
    // 将P分解为较小的子问题 P1 ,P2 ,...,Pk
    for (i = 1, i <= k, i++)
    	do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi
    T ← MERGE(y1,y2,...,yk) △ 合并子问题
    return(T)
}
```



**分治算法的划分策略**

**1、黑盒划分策略**

根据**问题的规模**对原问题进行划分，而不考虑划分对象的属性值，比如**合并排序**，**逆序对问题**

**2、白盒划分策略**

根据划分对象的**特定属性值**（也称之为参照值）把对象集合划分为若干个子集，比如**快速排序**、**最接近点对问题**

**3、减治策略**

根据白盒划分策略分割的部分子集可以直接排除，而不需要递归求解，可以认为减少了求解空间，称之为**减治策略**，比如**乘方运算**、**线性时间选择问题**



##### 经典问题

```
（1）二分搜索
（2）大整数乘法
（3）Strassen矩阵乘法
（4）棋盘覆盖
（5）合并排序
（6）快速排序
（7）线性时间选择
（8）最接近点对问题
（9）循环赛日程表
（10）汉诺塔
```

