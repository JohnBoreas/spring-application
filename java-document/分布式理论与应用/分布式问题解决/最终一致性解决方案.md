#### 什么是最终一致性

最终一致性是分布式计算里的一种内存一致性模型，它指对于已改变写的数据的读取，最终都能取得已更新的数据，但不完全保证能立即取得已更新的数据。这种模型通常可以实现较高的可用性。

**大意就是对已经修改的数据，我虽然不能保证立刻拿到，但我能够最终拿到**



解决：

一、业务场景

微服务中，需要跨多个服务去更新多个数据库的数据

![img](..\..\resource\微服务更新数据.png)

二、解决思路

1. 每个步骤完成后，生产一条消息给 MQ，告知下一步处理接下来的数据；
2. 消费者收到这条消息后，将数据处理完成后，与步骤一一样触发下一步；
3. 消费者收到这条消息后，如果数据处理失败，这条消息应该保留，直到消费者下次重试。



详细实现逻辑如下：

1. 调用端调用 Service A；（失败，直接返回失败）
2. Service A 将数据库中的 a1 改为 a2；（失败，回滚）
3. Service A 生成一条步骤 2（姑且命名为 Step2）的消息给到 MQ；（失败，回滚）
4. Service A 返回成功给调用端；（不处理）
5. Service B 监听 Step2 的消息，拿到一条消息。（MQ机制）
6. Service B 将数据库中的 b1 改为 b2；（回滚，消息重试）
7. Service B 生成一条步骤 3（姑且命名为 Step3）的消息给到 MQ；
8. Service B 将 Step2 的消息设置为已消费；
9. Service C 监听 Step3 的消息，拿到一条消息；
10. Service C 将数据库中的 c1 改为 c2；
11. Service C 将 Step3 的消息设置为已消费。



如果每个步骤失败了该怎么办？

1、调用端调用 Service A。

**解决方案：如果这步失败，直接返回失败给用户，用户数据不受影响。**

2、Service A 将数据库中的 a1 改为 a2。

**解决方案：如果这步失败，利用本地事务数据直接回滚就行，用户数据不受影响。**

3、Service A 生成一条步骤 2（姑且命名为 Step2）的消息给到 MQ。

**解决方案：如果这步失败，利用本地事务数据将步骤 2 直接回滚就行，用户数据不受影响。**

4、Service A 返回成功给调用端。

**解决方案：如果这步失败，不做处理。**

5、Service B 监听 Step2 的消息，拿到一条消息。

**解决方案：如果这步失败，MQ 有对应机制，我们无须担心。**

6、Service B 将数据库中的 b1 改为 b2。

**解决方案：如果这步失败，利用本地事务直接将数据回滚，再利用消息重试的特性重新回到步骤 5 。**

7、Service B 生成一条步骤 3（姑且命名为 Step3）的消息给到 MQ。

**解决方案：如果这步失败，MQ 有生产消息失败重试机制。要是出现极端情况，服务器会直接挂掉，因为 Step2 的消息还没消费，MQ 会有重试机制，然后找另一个消费者重新从步骤 5 执行。**

8、Service B 将 Step2 的消息设置为已消费。

**解决方案：如果这步失败，MQ 会有重试机制，找另一个消费者重新从步骤 5 执行。**

9、Service C 监听 Step3 的消息，拿到一条消息。

**解决方案：如果这步失败，参考步骤 5 的解决方案。**

10、Service C 将数据库中的 c1 改为 c2。

**解决方案：如果这步失败，参考步骤 6 的解决方案。**

11、Service C 将 Step3 的消息设置为已消费。

**解决方案：如果这步失败，参考步骤 8 的解决方案。**





其他问题：

1、消息重复消费

保持接口幂等性，看看是否允许被重复消费