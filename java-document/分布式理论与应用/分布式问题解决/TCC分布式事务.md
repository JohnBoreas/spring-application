TCC 的基本概念

**Try阶段：**

  完成所有业务检查（一致性），预留业务资源(准隔离性)

**Confirm阶段：**

  确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。

**Cancel阶段：**

   取消Try阶段预留的业务资源。



**`核心思想`** 是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。分为三个阶段：

- Try 阶段:主要是对业务系统做检测（一致性）及资源预留（准隔离性）
- Confirm 阶段:主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。(Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。
  )
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。(Cancel 操作满足幂等性)



**解决了协调者单点**，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。

**同步阻塞：** 引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。

**数据一致性**，有了补偿机制之后，由业务活动管理器控制一致性。

**缺点**：在Confirm,Cancel中都有可能失败。TCC属于**应用层**的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。




  1、try过程的本地事务，是保证资源预留的业务逻辑的正确性。

  2、confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的`补偿型事务`(Compensation-Based Transactions)。



try只是预留资源

confirm和cancel就是补偿事务，用于取消try阶段本地事务造成的影响



要改造为3个逻辑，Try-Confirm-Cancel。

1. 先是服务调用链路依次执行Try逻辑
2. 如果都正常的话，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务如果都正常的话，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务
3. 如果某个服务的Try逻辑有问题，TCC分布式事务框架感知到之后就会推进执行各个服务的Cancel逻辑，撤销之前执行的各种操作

这就是所谓的TCC分布式事务。

TCC分布式事务的核心思想，说白了，就是当遇到下面这些情况时，

- 某个服务的数据库宕机了
- 某个服务自己挂了
- 那个服务的redis、elasticsearch、MQ等基础设施故障了
- 某些资源不足了，比如说库存不够这些

1.先来Try一下，不要把业务逻辑完成，先试试看，看各个服务能不能基本正常运转，能不能先冻结我需要的资源。

2.如果Try都ok，也就是说，底层的数据库、redis、elasticsearch、MQ都是可以写入数据的，并且你保留好了需要使用的一些资源（比如冻结了一部分库存）。

3.接着，再执行各个服务的Confirm逻辑，基本上Confirm就可以很大概率保证一个分布式事务的完成了。

4.那如果Try阶段某个服务就失败了，比如说底层的数据库挂了，或者redis挂了，等等。
此时就自动执行各个服务的Cancel逻辑，把之前的Try逻辑都回滚，所有服务都不要执行任何设计的业务逻辑。保证大家要么一起成功，要么一起失败。





TCC事务框架 **`都是要记录一些分布式事务的活动日志的`**，可以在磁盘上的日志文件里记录，也可以在数据库里记录。保存下来分布式事务运行的各个阶段和状态。





TCC两阶段提交与XA两阶段提交的区别是：

  **XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。**

  **TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。**



**TCC事务的优缺点：**

   **优点：**XA两阶段提交资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现。有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能地下问题。

  **缺点：**主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。还是航班预定案例，原来只需要提供一个购买接口，现在需要改造成try、confirm、canel3个接口，开发成本高。