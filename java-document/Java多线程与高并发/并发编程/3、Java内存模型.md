

#### Java内存模型的基础

**（1）并发编程模型的两个关键问题**

线程之间如何通信、线程之间如何同步（这里的线程是指并发执行的活动实体）

通信是指线程之间以何种机制来交换信息

线程之间的通信机制有两种：共享内存和消息传递。

在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。



同步是指程序中用于控制不同线程间操作发生相对顺序的机制。



（2）Java内存模型的抽象结构

​	Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见

线程A与线程B之间通信：

1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。

2）线程B到主内存中去读取线程A之前已更新过的共享变量。

![Java内存模型的抽象结构示意图.png](../..\resource\Java内存模型的抽象结构示意图.png)

​	线程A在向线程B发送消息，这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。

![线程之间的通信图.png](../..\resource\线程之间的通信图.png)



（3）从源代码到指令序列的重排序

* 重排序分3种类型：

```shell
1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
```

* 从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序：

![从源码到最终执行的指令序列的示意图](../..\resource\从源码到最终执行的指令序列的示意图.png)

​	对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。

​	对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。

​	JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。



（4）并发编程模型的分类







