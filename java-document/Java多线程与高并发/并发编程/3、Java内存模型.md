

#### Java内存模型的基础

**（1）并发编程模型的两个关键问题**

1、线程之间如何通信、线程之间如何同步（这里的线程是指并发执行的活动实体）

2、通信是指线程之间以何种机制来交换信息



**线程之间的通信机制有两种：**共享内存和消息传递。

在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。



同步是指程序中用于控制不同线程间操作发生相对顺序的机制。



**（2）Java内存模型的抽象结构**

​	Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见

`线程A与线程B之间通信：`

1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。

2）线程B到主内存中去读取线程A之前已更新过的共享变量。

![Java内存模型的抽象结构示意图.png](../..\resource\Java内存模型的抽象结构示意图.png)

​	线程A在向线程B发送消息，这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。

![线程之间的通信图.png](../..\resource\线程之间的通信图.png)



**（3）从源代码到指令序列的重排序**

* 重排序分3种类型：

```shell
1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
```

* 从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序：

![从源码到最终执行的指令序列的示意图](../..\resource\从源码到最终执行的指令序列的示意图.png)

​	对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。

​	对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。

​	JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。



**（4）并发编程模型的分类**

* 现代的处理器先写缓冲区，再写入内存。

* 写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟

1）由于写缓冲区仅对自己的处理器可见，它会导致处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致

![处理器操作内存的执行结果](../..\resource\处理器操作内存的执行结果.png)

​	A和B可以同时把共享变量写入缓冲区（A1，B1），再从内存中读取另一共享变量（A2，B2），最后才刷新缓存区数据到内存中（A3，B3）。当以这种时序执行时，程序就可以得到x=y=0的结果。

![处理器和内存的交互](../..\resource\处理器和内存的交互.png)

2）为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序

![内存屏障类型表](../..\resource\内存屏障类型表.png)

StoreLoad Barriers比较常用，执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。



**（5）happens-before简介**

​	在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。

​	happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见

规则：

```powershell
·程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
·监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
·volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的
读。
·传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
```

![happens-before与JMM的关系](../..\resource\happens-before与JMM的关系.png)





#### 重排序

指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

（1）数据依赖性

* 定义：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

![数据依赖类型表](../..\resource\数据依赖类型表.png)

	1.编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。
	
	2.数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。



（2）as-if-serial语义

语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。

*编译器、runtime和处理器都必须遵守as-if-serial语义。*

```java
// A和C之间存在数据依赖关系，B和C之间也存在数据依赖关系，C不能被重排序到A和B的前面
double pi = 3.14; // A
double r = 1.0; // B
double area = pi * r * r; // C
```

![程序的两种执行顺序](../..\resource\程序的两种执行顺序.png)

（3）程序顺序规则

软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能提高并行度。



（4）重排序对多线程的影响

​	在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

```java
// 操作1和操作2做了重排序，操作3和操作4做了重排序
class ReorderExample {
    int a = 0;
    boolean flag = false;
    public void writer() {
        a = 1; 			// 1
        flag = true; 	// 2
    }
    Public void reader() {
        if (f?lag) { 		// 3
            int i = a * a; 	// 4
            ……
    	}
    }
}
```





#### 顺序一致性

在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。

（1）数据竞争与顺序一致性

