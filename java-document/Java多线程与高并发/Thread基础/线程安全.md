#### 1、线程安全

（1）什么是线程安全？

当多个线程访问某个类时，这个类始终能表现出正确的行为，那么这个类是线程安全的



线程安全

“线程安全”也不是指线程的安全，而是指内存的安全。

进程：为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。

堆（内存）：每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，进程中的公共变量都在堆里

栈内存：操作系统会为每个线程分配属于它自己的内存空间，局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道



（2）如何保证线程安全？

无状态对象一定是线程安全的

无状态就是一次操作，不能保存数据。

无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。

```shell
①原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized，lock，atomic类）；
②可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
③有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。
可以通过volatile、synchronized、lock保证有序性。

不在线程中共享该变量
将该变量修改为不可变类型
访问变量时使用同步
```

保证线程安全：

1、每个线程里都copy一份数据：

ThreadLocal就是，把一个数据复制N份，每个线程在运行时都会拷贝一份存储到自己的本地，互不影响。

2、只能读取，不能修改。

其实就是常量或只读变量，final

3、数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。局部变量

4、并发量大，变量需要多个线程操作时，使用锁

为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。相当于悲观锁

Lock、synchronize

5、在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS

在修改前检查，被修改后替换，相当于乐观锁



（3）线程安全级别

```shell
①不可变的——也就是有final修饰的类，例如String、Long，它们就不用外部同步。
②无条件的线程安全——这个类没有final修饰，但其内部已经保证了线程安全，例如并发包中的并发集合类，同样它们无需外部同步。
③有条件的线程安全——这个有的方法需要外部同步，而有的方法则和“无条件的线程安全”一样无需外部同步。
④非线程安全——这就是最“普通”的类了，内部的任何方法想要保证安全性就必须要外部同步。
```





→ 线程安全
死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系



1、什么是线程安全

2、如何确保线程安全

3、线程安全的实现



加锁机制：

（1）内置锁

synchronize（lock）{}

（2）重入--避免死锁的发生

一种实现方式是：为每个锁关联一个获取计数值和一个所有者对象；