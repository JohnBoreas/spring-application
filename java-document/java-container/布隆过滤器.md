布隆过滤器是一种高效的数据结构，用于快速检索一个元素是否属于一个集合中，它可以判断某个元素是否“可能”存在于集合中，但不能确定元素是否一定存在于集合中。

布隆过滤器通常用于缓存、数据索引等领域，它可以将查询时需要的IO次数和计算成本大大降低，从而提高查询效率。



布隆过滤器的原理可以概括为以下几个步骤：

1. 初始化：布隆过滤器初始化时，需要指定一个位数组和一组哈希函数。位数组通常初始化为0，而哈希函数可以是多个，每个哈希函数可以将输入映射为不同的位数组下标。
2. 添加元素：当向布隆过滤器中添加一个元素时，需要对该元素进行哈希计算，得到多个哈希值，并将对应的位数组中的值设为1。
3. 查询元素：当查询一个元素是否存在于布隆过滤器中时，需要对该元素进行哈希计算，得到多个哈希值，并检查对应的位数组中的值是否为1。如果有任何一个位数组中的值为0，则该元素不在布隆过滤器中；否则该元素可能存在于布隆过滤器中。

布隆过滤器的核心思想是通过哈希函数将输入映射为位数组的下标，通过对位数组中的值进行操作，实现快速判断一个元素是否存在于布隆过滤器中。由于哈希函数的不确定性，可能会导致两个不同的元素映射到同一个位数组下标上，这就会造成误判。因此，布隆过滤器不保证判断的结果是100%准确的，但是可以通过增加位数组的长度和哈希函数的数量，以及使用合适的哈希函数来降低误判率。



容量

2<<30 ，2亿数据占用550m内存，重复27w

2<<29，2亿占200m，重复300w





```java
## 容量测试
// Java 虚拟机中的空闲内存量。
Long fm = Runtime.getRuntime().freeMemory();
// Java 虚拟机中的内存总量。
Long tm = Runtime.getRuntime().totalMemory();
// Java 虚拟机试图使用的最大内存量。
Long mm = Runtime.getRuntime().maxMemory();
System.out.println("fm:"+fm+",tm:"+tm+",mm:"+mm+",use:"+(tm - fm));// used在用内存);
Long temp=(tm - fm);
SckbBloomFiltter filter=new SckbBloomFiltter(2<<30);
int dup=0;
int total=200000000;
int notIn=0;

for(int i=0;i<=total;i++){
    String e = "46" + i +"123";
    if (filter.isContains(e)) {
        dup++;
    }else {
        filter.add(e);
        notIn++;
    }
}

System.out.println("in :"+dup+"; total:"+total+" ;not in :"+notIn);

fm = Runtime.getRuntime().freeMemory();// Java 虚拟机中的空闲内存量。
tm = Runtime.getRuntime().totalMemory();// Java 虚拟机中的内存总量。
mm = Runtime.getRuntime().maxMemory();// Java 虚拟机试图使用的最大内存量。
System.out.println("fm:"+fm+",tm:"+tm+",mm:"+mm+",use:"+(tm - fm));
System.out.println((tm-fm-temp)/1024/1024);
```

